import { ChangelogWriter } from '../changelogWriter.ts';
import { Commit } from '../commit.ts';
import { type Args, inject, injectable, readLines } from '../../deps.ts';
import { capitalize, fileExists } from '../util.ts';
import { GitProvider } from '../gitProvider.ts';
import { Git } from '../git.ts';
import '../../args.ts';

@injectable()
export class DefaultWriter extends ChangelogWriter {
  static HEADER = /^\s?##\s?(.*)$/m;

  public gitProvider: GitProvider = new GitProvider();

  constructor(
    @inject('args') public readonly args: Args,
    public readonly git: Git,
  ) {
    super();
  }

  buildHeader() {
    const {
      changelogHeader = `
# Changelog

All notable changes to this project will be documented in this file.

File has been auto generated by version-bump. See [version-bump](https://deno.land/x/version_bump)
`,
    } = this.args;
    return changelogHeader;
  }

  buildChangelogEntries(commits: Commit[]) {
    const groups = [
      {
        test: /^fix/i,
        heading: 'Bug Fixes',
        show: true,
      },
      {
        test: /^feat/i,
        heading: 'Features',
        show: true,
      },
      {
        test: /^test/i,
        show: false,
        heading: 'Testing',
      },
      {
        test: /^.*$/,
        heading: 'Other',
        show: this.args.firstRelease,
      },
    ];

    const reduced = commits.reduce((cum, cur) => {
      const key = groups.find((group) => group.test.test(cur.subject));
      if (!key?.show) {
        return cum;
      }
      if (!cum[key.heading]) {
        cum[key.heading] = [];
      }
      cum[key.heading].push(cur);
      return cum;
    }, {} as Record<string, Commit[]>);

    const output: string[] = [];

    for (const [heading, commits] of Object.entries(reduced)) {
      output.push(
        `### ${heading}`,
        ...(commits.map((commit) => this.buildChangelogEntry(commit))),
        '',
      );
    }

    return output.join('\n');
  }

  buildChangelogEntry(commit: Commit) {
    const [, ...subject] = commit.subject.split(':');
    return `- ${capitalize(subject.join(':'))} [${commit.sha.slice(0, 8)}](${
      this.gitProvider.commitUrl(commit.sha)
    })`;
  }

  async write(filePath: string, newVersion: string, commits: Commit[]) {
    const contents: string[] = [];
    if (await fileExists(filePath)) {
      const open = await Deno.open(filePath);
      let inserted = false;
      for await (const line of readLines(open)) {
        if (!inserted && DefaultWriter.HEADER.test(line)) {
          contents.push(
            `## ${newVersion}`,
            '',
            this.buildChangelogEntries(commits),
            '',
          );
          inserted = true;
        }
        contents.push(line);
      }
      Deno.close(open.rid);
    } else {
      contents.push(
        this.buildHeader(),
        `## ${newVersion}`,
        '',
        this.buildChangelogEntries(commits),
      );
    }
    try {
      await Deno.writeTextFile(filePath, contents.join('\n'));
      return true;
    } catch (e) {
      console.error(e);
      return false;
    }
  }

  async read(filePath: string) {
    if (!(await fileExists(filePath))) {
      console.info(`Changelog file not found at ${filePath}`);
      return '';
    }
    const lines = [];
    const file = await Deno.open(filePath);
    for await (const line of readLines(file)) {
      lines.push(line);
    }
    return lines.join('\n');
  }

  setGitProvider(provider: GitProvider) {
    this.gitProvider = provider;
  }
}

export default DefaultWriter;
